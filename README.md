# Реализация алгоритма сжатия Шеннона-Фано на языке С++

## Скриншоты работы программы

![image](https://github.com/user-attachments/assets/544aee7b-7a5e-4ab2-9064-bfa6fd85ca85)

## Описание проблемы

Мы знаем, что каждый символ хранится в виде последовательности из 0 и 1 и занимает 8 бит. Это называется кодированием фиксированной длины, поскольку каждый символ использует одинаковое фиксированное количество битов для хранения. Однако такое кодирование является неэффективным, так как не учитывает различия в частоте появления символов, в результате чего часто используются слишком длинные коды. Все это приводит к избыточным затратам на хранение и более длительным временным интервалам чтения, записи, передачи информации.

## Описание решения

Основная идея заключается в кодировании переменной длины. Мы можем использовать тот факт, что некоторые символы в тексте встречаются чаще, чем другие, чтобы разработать алгоритм, который будет представлять ту же последовательность символов меньшим количеством битов. При кодировании переменной длины мы присваиваем символам переменное количество битов в зависимости от частоты их появления в данном тексте. В конечном итоге некоторые символы могут занимать всего 1 бит, а другие 2 бита, 3 или больше.

## Алгоритм сжатия Шеннона-Фано - теория

Алгоритм Шеннона — Фано — один из первых алгоритмов сжатия, который впервые сформулировали американские учёные Клод Шеннон и Роберт Фано. Алгоритм использует коды переменной длины: часто встречающийся символ кодируется кодом меньшей длины, редко встречающийся — кодом большей длины. Коды Шеннона — Фано — префиксные, то есть никакое кодовое слово не является префиксом любого другого. Это свойство позволяет однозначно декодировать любую последовательность кодовых слов.

Сам алгоритм выглядит следующим образом:
1) Определите алфавит сообщения и частоту появления каждого символа.
2) Создайте узел-корень дерева Шеннона-Фано, включающий в себя последовательность символов с их частотой.
3) Узел-родитель делиться на два узла-потомка, суммарная частота которых должна быть максимально идентична. Этот процесс повторяется до тех пор, пока в последовательности узла не останется один символ.
4) Каждому символу назначается код, который получается путем прохождения от корня до узла символа. При движении влево добавляется '0', при движении вправо — '1'. В результате получается таблица кодов для каждого символа.
5) С помощью сгенерированных кодов исходные данные заменяются на их бинарные представления, что приводит к уменьшению общего объема данных.

## Алгоритм сжатия Шеннона-Фано - реализация на языке С++

### Кодирование
1) На вход программе поступает текст - с клавиатуры либо из файла Текст.txt.
2) Создается и сортируется в порядке убывания частотная таблица.
3) На основе полученного текста создаем корень нашего дерева Шеннона-Фано (createNode) и "выращиваем" его (функция growShFTree(root))
4) Обходим все дерево, формируя коды для каждого символа (encode).
5) Заменяем символы в оригинальном тексте на его код.

Раскодирование осуществляется функцией decode, которая, начиная с корня дерева, идет к левому потомку, если соответствующий символ кода = 0 и к правому, если = 1 до тех пор, пока не дойдет до листа с символом. 






